---
title: "Supplementary Materials"
author: "Peter J. Kohler, Oda Åsgard, and Alasdair D. F. Clarke"
date:
output: bookdown::html_document2
---

I have set `echo=FALSE` so that most of the code chunks will not display. Please refer to the .Rmd file for source code.

```{r setup, include=FALSE}

library(bookdown)
library(tidyverse)
library(brms)
library(tidybayes)
library(ggridges)
library(latex2exp)
library(see)
library(ggthemes)
library(patchwork)

knitr::opts_chunk$set(echo = FALSE, message=FALSE, fig.align='center')

# specify some colours to use in the plots
v_cols <- ggthemes::ptol_pal()(6)

# read in some helper functions that will be used later
source("scripts/helper_functions.R")
```

# Loading packages and importing data

##  Packages

Details of packages, etc, are given below.

```{r}
sessionInfo()
```

Use multiple cores and set number of iterations. 
```{r}
options(mc.cores = parallel::detectCores())
n_iter <- 10000

# make empty lists to store things in
my_models <- list()
my_samples <- list()
comp_summary <- list()
subgroup_comp <- list()
```

## Import Data

Here we import our data and make some sumamry plots.

### EEG Data

Importing the odd-harmonic EEG data from six electrodes region-of-interest over occipital cortex.

\tiny
```{r eeg_import}
fl <- "rms_Occ_Odd.csv"

# set column types
my_cols <- cols(
  .default = col_double(),
  Row = col_character()
)

#import
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wg = "Row") %>%
  gather("subject", "rms", -wg) %>%
  glimpse() -> d_eeg 
```
 
It's clearly skewed, and negative display duration are impossible, so will fit a `glm` with `family = 'lognormal`.

```{r cache=TRUE, fig.cap = "Data are the root-mean-squaured (rms) over the odd-harmonic filtered waveforms."}
d_eeg %>% ggplot(aes(x = rms)) + 
    geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
    theme_lucid()
```

### Threshold Data

Here we import that data and select the columns that we're interested in. Threshold gives the required display duration (in seconds) for the two stimuli to allow for accurate discrimination. 

```{r threshold_import}
fl <- "thresholds"

my_cols_threshold <- cols(
  person = col_character(),
  group = col_character(),
  staircase = col_double(),
  threshold = col_double(),
  log_threshold = col_double()
)

read_csv("../Experiment/process_results/thresholds.csv", col_types = my_cols_threshold) %>%
  select(subject = "person", wg = "group", threshold) %>%
  glimpse() -> d_dispthresh 

rm(my_cols_threshold)
```
 
As above, a summary of the data.

```{r, fig.cap="Histogram of the display duration thresholds."}
d_dispthresh %>% ggplot(aes(x = threshold)) + 
    geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
    theme_lucid()
```

Again, we have a skewed distribution, so will fit with `family = 'lognormal'`.

### Control Data

In addition to the primary EEG data set, we are also importing two control data sets which are (a) even harmonic data from the same occipital electrodes, and (b) odd harmonic data 
from six parietal electrodes (see main paper).

```{r import_control}

fl <- "rms_Occ_Even.csv"

read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wg = "Row") %>%
  gather("subject", "rms", -wg) -> d_eeg_occ_even

fl <- "rms_Par_Odd.csv"

read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wg = "Row") %>%
  gather("subject", "rms", -wg) -> d_eeg_par_odd

rm(my_cols, fl)
```

# Bayesian Analysis 

Here are the details of the Bayesian multi-level modelling. Our general approach is:

*  Use weakly-informative priors.
*  Fit a multi-level model using the lognormal distribution.
  + independent variable (wallpaper group) and one dependent variable (rms or threshold).
  + maximal random effect structure.
* Check model fit (r̂ statistics and trace plots).
* Extract mcmc samples from the posterior distributions.
* Use these samples to estimate the difference between sub- and super-groups.

## Define Priors

In this section we will specify some priors. We then then use a prior-predictive check to assess whether the prior is reasonable or not (i.e., on the same order of magnitude as our measurements).

### Fixed Effects

Our independent variable is a categorical factor with 16 levels. We will drop the intercept from our model and instead fit a coefficent for each factor level ($y \sim x - 0$). As our dependant variable will be log-transformed, we can use the priors below: 

```{r, echo = TRUE}
prior <- c(
  set_prior("normal(0,2)", class = "b"),    
  set_prior("cauchy(0,2)", class = "sigma"))
```

### Group-level Effects

We will keep the default weakly informative priors for the group-level (‘random’) effects. From the brms documentation:

> [...] restricted to be non-negative and, by default, have a half student-t prior with 3 degrees of freedom and a scale parameter that depends on the standard deviation of the response after applying the link function. Minimally, the scale parameter is 10. This prior is used (a) to be only very weakly informative in order to influence results as few as possible, while (b) providing at least some regularization to considerably improve convergence and sampling efficiency.

### Prior Predictive Check

Now we can specify our Bayesian multi-level model and priors. Note that as we are using  `sample_prior = 'only'`, the model will not learn anything from our data.  

```{r eeg_prior_pred_check, cache=TRUE, echo=TRUE}
m_prior <- brm(data = d_eeg, 
  rms ~ wg-1 + (1|subject),
  family = "lognormal", 
  prior = prior, 
  iter = n_iter ,
  sample_prior = 'only')
```

We can use this model to generate data.

```{r, fig.cap="The density plot shows the distribution of the empirical data, while the blue line shows the 66% and 95% prediction intervals."}
prior_samples <- get_model_samples(m_prior) 

# Tidy up a little
prior_predictions <- get_model_predictions(prior_samples)%>% glimpse()

# # And now plot
p1 <- plot_model_output(prior_predictions, d_eeg,
                   "odd-harmonic data from \noccipital electrodes", "cornflowerblue", "log(rms)")

p2 <- plot_model_output(prior_predictions, d_dispthresh,
                   "display duration threshold data", "cornflowerblue", "log(ms)")

# draw pot
plt <- p1 + p2
plt + plot_annotation(title = 'Prior Predictive Checks')
```

We can see that i) our priors are relatively weak as the predictions span several orders of magnitide, and ii) our empirical data falls within this range. 


## Compute Posterior 

### Fit Model to EEG Data

We will now fit the model to the data.

```{r eeg_fit_model, cache=TRUE}
m_eeg <- brm(data = d_eeg, 
             rms ~ wg-1 + (1|subject),
             family = "lognormal", 
             prior = prior, iter = n_iter,
             control = list(adapt_delta = 0.99))

summary(m_eeg)
```


We will now have at what the model predicts for the average participant (i.e, ignoring the random intercepts). If anybody else would like to suggest over sensible ways to summarise this model, do let me know! I've been trying to use some of the functions from the `tidybayes` package, and they don't (yet?) have much on random effects. 


```{r, fig.cap ="The density plot shows the distribution of the empirical data, while the blue line shows the 66% and 95% prediction intervals."}

 # Extract samples from model
my_samples$eeg <- get_model_samples(m_eeg)
 
 # Tidy up a little
 my_models$eeg <- get_model_predictions(my_samples$eeg)
 
 # Plot
plot_model_output(
  my_models$eeg, d_eeg,
  "Model Fits for the odd-harmonic data from occipital electrodes",
  "orangered3", 
  "log(rms)")
```

### Fit Model to Display Duration Threshold Data

We will now fit the model to the data.

```{r threshold_fit_model, cache=TRUE, echo=FALSE}
m_threshold <- brm(data = d_dispthresh, 
                   threshold ~ wg-1 + (1|subject),
                   family = "lognormal", 
                   prior = prior, iter = n_iter,
                   control = list(adapt_delta = 0.99))

summary(m_threshold)
```

```{r, fig.cap ="The density plot shows the distribution of the empirical data, while the blue line shows the 66% and 95% prediction intervals."}
# Extract samples from model
my_samples$threshold <- get_model_samples(m_threshold)

# Tidy up a little
my_models$threshold <- get_model_predictions(my_samples$threshold)

# Plot
plot_model_output(my_models$threshold, d_dispthresh, 
                  "Model Fits: Display Duration Threshold", "orangered3", "threshold (ms)")
```
