---
title: "Bayesian Modelling"
author: "Alasdair DF Clarke"
date: "21 October 2019"
output: 
  html_document:
    number_sections: true
---

I have set `echo=FALSE` so that most of the code chunks will not display. Please refer to the .Rmd file for source code.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE)

# specify some colours to use in the plots
v_cols <- ggthemes::ptol_pal()(6)
```

# Loading packages and importing data

##  Packages

Details of packages, etc, are given below.

```{r packages, results='hold'}
library(tidyverse)
library(brms)
library(tidybayes)
library(ggridges)
library(latex2exp)
library(see)
library(ggthemes)
```

```{r}
sessionInfo()
```

Use multiple cores and set number of iterations. 
```{r}
options(mc.cores = parallel::detectCores())
n_iter <- 10000

# make empty lists to store things in
my_models <- list()
my_samples <- list()
comp_summary <- list()
subgroup_comp <- list()
```

## Import Data

Import data and quickly plot.

### EEG Data

Importing the eeg occ odd data.

```{r eeg_import, cache=TRUE}
fl <- "rms_Occ_Odd.csv"

# set column types
my_cols <- cols(
  .default = col_double(),
  Row = col_character()
)

#import
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wallpaper_group = "Row") %>%
  gather("subject", "rms", -wallpaper_group) %>%
  glimpse() -> d_eeg 
```
 
It's clearly skewed, and negative display duration are impossible, so will fit a `glm` with `family = 'lognormal`.

```{r}
d_eeg %>% ggplot(aes(x = rms)) + 
    geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
    theme_lucid()
```

### Threshold Data

Here we import that data and select the columns that we're interested in. Threshold gives the required display duration (in seconds) for the two stimuli to allow for accurate discrimination. 

```{r threshold_import, cache=TRUE}
fl <- "thresholds"

my_cols_threshold <- cols(
  person = col_character(),
  group = col_character(),
  staircase = col_double(),
  threshold = col_double(),
  log_threshold = col_double()
)

read_csv("../Experiment/analysis/thresholds.csv", col_types = my_cols_threshold) %>%
  select(subject = "person", wallpaper_group = "group", threshold) %>%
  glimpse() -> d_dispthresh 

rm(my_cols_threshold)
```
 
As above, eyeball the data…

```{r}
d_dispthresh %>% ggplot(aes(x = threshold)) + 
    geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
    theme_lucid()
```
Again, we have a skewed distribution, so will fit with `family = 'lognormal'`.

### Control Data

We will also include some control EEG data. These are the …. < details from Peter >

```{r import_control}

fl <- "rms_Occ_Even.csv"

read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wallpaper_group = "Row") %>%
  gather("subject", "rms", -wallpaper_group) -> d_eeg_occ_even

fl <- "rms_Par_Odd.csv"

read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wallpaper_group = "Row") %>%
  gather("subject", "rms", -wallpaper_group) -> d_eeg_par_odd

rm(my_cols, fl)
```

# Bayesian Analysis 

Here are the details of the Bayesian multi-level modelling. Our general approach is:

*  Use weakly-informative priors.
*  Fit a multi-level model using the lognormal distribution.
  + independent variable (wallpaper group) and one dependent variable (rms/threshold).
  +maximal random effect structure.
* Check model fit (r̂ statistics and trace plots).
* Extract mcmc samples from the posterior distributions.
* Use these samples to estimate the difference between sub- and super-grounps.

## Define Priors

First we have to define some priors: are we happy with these?

We will keep the default priors for the group-level (‘random’) effects. From the brms documentation:

> [...] restricted to be non-negative and, by default, have a half student-t prior with 3 degrees of freedom and a scale parameter that depends on the standard deviation of the response after applying the link function. Minimally, the scale parameter is 10. This prior is used (a) to be only very weakly informative in order to influence results as few as possible, while (b) providing at least some regularization to considerably improve convergence and sampling efficiency.

Now we can fit a Bayesian multi-level model. First we will run with sample_prior = 'only' to check that our priors appear reasonable.

```{r}
## define some priors
prior <- c(
  set_prior("normal(0,2)", class = "b"),    
  set_prior("cauchy(0,2)", class = "sigma"))
```

Now we can fit a Bayesian multi-level model. First we will run with `sample_prior = 'only'` to check that our priors appear reasonable.

```{r eeg_prior_pred_check, cache=TRUE}
m_prior <- brm(data = d_eeg, 
  rms ~ wallpaper_group-1 + (1|subject),
  family = "lognormal", 
  prior = prior, 
  iter = n_iter ,
  sample_prior = 'only')
```


Now we will define some handy functions so we can reuse the same code to visualise the results of the model

```{r}
get_model_samples <- function(my_model) {
  
  my_samples <- posterior_samples(my_model)
  
  names(my_samples)  %>% 
    gsub('[b_]*wallpaper_group', "", .) -> names(my_samples)
  
  return(my_samples)
}

get_model_predictions <- function(my_samples) {
  my_samples %>%
    as_tibble() %>% 
    mutate_all(exp) %>%
    select(P2, PM, PG, CM, PMM, PMG, PGG, CMM, P4, P4M, P4G, P3, P3M1, P31M, P6, P6M) %>%
    gather() -> my_model_predictions
  
  return(my_model_predictions)
}

plot_model_output <- function(mdat, edat, my_title, my_colour, x_label) {
  x_var <- names(edat)[3]
  # plot model fit (mdat) against empiricaly data (edat)
  ggplot(mdat, aes(x = value, y = key)) +
      stat_pointintervalh(.width = c(.66, .95), colour = my_colour) +
      geom_density_ridges(data = edat,aes_string(x = x_var, "wallpaper_group"),
        fill = "grey",
        alpha = 0.25,
        scale = 2,
        bandwidth = 0.05) +
      scale_x_log10(x_label) +
    ggtitle(my_title) +
      theme_lucid()
}
```

Now we can use these functions to visualise the predictions made by the model:

```{r}

prior_samples <- get_model_samples(m_prior) %>% glimpse()

# Tidy up a little
prior_predictions <- get_model_predictions(prior_samples)%>% glimpse()

# # And now plot
plot_model_output(prior_predictions, d_eeg,
                   "Prior Predictive Check: EEG RMS", "deepskyblue3", "rms")

```

The density plots show the distribution of the data, while the point interval shows the median with $66\%$ and $95\%$ quantiles for our prior. 

It looks like our priors are in the right range for the data. 

### Prior Predictive Check for Display Duration Data

Now we can repeat this process (with the same priors) for the display duration threshold data. 

```{r dispthresh_prior_pred_check, cache=TRUE, echo=FALSE}
m_prior <- brm(data = d_dispthresh, 
               threshold ~ wallpaper_group-1 + (1|subject),
               family = "lognormal", 
               prior = prior, iter = n_iter ,
               sample_prior = 'only')

# Extract samples from model
prior_samples <- get_model_samples(m_prior)

# Tidy up a little
prior_predictions <- get_model_predictions(prior_samples)

plot_model_output(prior_predictions, d_dispthresh, 
                  "Prior Predictive Check: Display Duration Thresholds", "deepskyblue3", "display threshold (ms)")
```

The density plots show the distribution of the data, while the point interval shows the median with $66\%$ and $95\%$ quantiles for our prior. 

It looks like our priors are in the right range for the data. 

## Compute Posterior 

### Fit Model to EEG Data

We will now fit the model to the data.

```{r eeg_fit_model, cache=TRUE}
m_eeg <- brm(data = d_eeg, 
             rms ~ wallpaper_group-1 + (1|subject),
             family = "lognormal", 
             prior = prior, iter = n_iter,
             control = list(adapt_delta = 0.99))

summary(m_eeg)
```


Hopefully all the $\hat{r} = 1$ and there aren't any warning messages, etc. 

We will now have at what the model predicts for the average participant (i.e, ignoring the random intercepts). If anybody else would like to suggest over sensible ways to summarise this model, do let me know! I've been trying to use some of the functions from the `tidybayes` package, and they don't (yet?) have much on random effects. 



```{r}
 # Extract samples from model

my_samples$eeg <- get_model_samples(m_eeg)
 
 # Tidy up a little
 my_models$eeg <- get_model_predictions(my_samples$eeg)
 
 # Plot
 plot_model_output(my_models$eeg, d_eeg, 
                   "Model Fits: EEG RMS", "orangered3", "rms")
```



### Fit Model to Display Duration Threshold Data

We will now fit the model to the data.

```{r threshold_fit_model, cache=TRUE, echo=FALSE}
m_threshold <- brm(data = d_dispthresh, 
                   threshold ~ wallpaper_group-1 + (1|subject),
                   family = "lognormal", 
                   prior = prior, iter = n_iter,
                   control = list(adapt_delta = 0.99))

summary(m_threshold)
```

Hopefully all the $\hat{r} = 1$ and there aren't any warning messages, etc. 

We will now have at what the model predicts for the average participant (i.e, ignoring the random intercepts). If anybody else would like to suggest over sensible ways to summarise this model, do let me know! I've been trying to use some of the functions from the `tidybayes` package, and they don't (yet?) have much on random effects. 

```{r}
# Extract samples from model
my_samples$threshold <- get_model_samples(m_threshold)

# Tidy up a little
my_models$threshold <- get_model_predictions(my_samples$threshold)

# Plot
plot_model_output(my_models$threshold, d_dispthresh, 
                  "Model Fits: Display Duration Threshold", "orangered3", "threshold (ms)")
```

### EEG Control Data

We will also fit models to the blah and blah data as control conditions.

First for the occ_even data...

```{r occ_even_model, cache=TRUE}

m_eeg_occ_even <- brm(data = d_eeg_occ_even, 
                      rms ~ wallpaper_group-1 + (1|subject),
                      family = "lognormal", 
                      prior = prior, iter = n_iter,
                      control = list(adapt_delta = 0.99))

# Extract samples from model
my_samples$occ_even <- get_model_samples(m_eeg_occ_even)
```


And now for th par_odd data...

```{r par_odd_model, cache=TRUE}

m_eeg_par_odd <- brm(data = d_eeg_par_odd, 
                     rms ~ wallpaper_group-1 + (1|subject),
                     family = "lognormal", 
                     prior = prior, iter = n_iter,
                     control = list(adapt_delta = 0.99))

my_samples$par_odd <- get_model_samples(m_eeg_par_odd)
``` 

# Subgroup Comparisons

Helper function to do make comparisons and create plot:
  
```{r}
source("get_subgroup_comparisons.R")
```

```{r subgroup_comparisons, cache=TRUE}

subgroup_comp$eeg <- get_subgroup_comparisons(my_samples$eeg, 2*n_iter) %>% glimpse()
subgroup_comp$threshold <- get_subgroup_comparisons(my_samples$threshold, 2*n_iter) 

# Also compute for control datasets
subgroup_comp$occ_even <- get_subgroup_comparisons(my_samples$occ_even, 2*n_iter) 
subgroup_comp$par_odd  <- get_subgroup_comparisons(my_samples$par_odd,  2*n_iter) 

```

## EEG RMS

Finally, I calculate the probability that the difference between subgroup and supergroup is larger than zero (small than zero for the display duration) given the data. This information is then binned so we can colour in the posterior density plots.

First we will define a handy function that we can reuse a few times. 

```{r define_comparison_summary_function, echo=TRUE}
comparison_summary <- function(subgroup_comp_dat, greater, measurement_lab) {
  # compute probabilties
  subgroup_comp_dat %>%
    group_by(key, index, normal) %>%
    summarise(
      mean_value = mean(value),
      prob_one_tailed = if_else(greater == TRUE, mean(value > 0), mean(value < 0)))  %>%
    mutate(
      measurement = measurement_lab,
      index_labs = as.numeric(as.factor(index)),
      lab_cols = v_cols[index_labs],
      prob_cat = cut(prob_one_tailed, c(0, 0.5, 0.75, 0.9, 0.99, 1))) -> comp_summary_dat
  
  return(comp_summary_dat)
}
```

Now we will use it!
  
```{r, plot_eeg_comp, fig.height=8}
# compute probabilties
comp_summary$eeg <- comparison_summary(subgroup_comp$eeg, TRUE, 'rms') %>% glimpse()

subgroup_comp$eeg <- full_join(
  subgroup_comp$eeg, 
  comp_summary$eeg, 
  by = c("key", "index", "normal"))

# Finally, plot everything:
p1 <- plot_comparisons(
  filter(subgroup_comp$eeg, index == 2),
  filter(comp_summary$eeg, index == 2), 
  1)

p2 <-plot_comparisons(
  filter(subgroup_comp$eeg, index != 2),
  filter(comp_summary$eeg, index != 2), 
  2)

both_plts <- cowplot::plot_grid(p1, p2, ncol = 2, align="hv")
both_plts
```

## Display Duration Threshold

We can do the same for the display duration thresholds. 

```{r plot_threshold_comp, fig.height=8}

# compute probabilties
comp_summary$threshold <- comparison_summary(subgroup_comp$threshold, FALSE, 'threshold') %>% glimpse()

subgroup_comp$threshold <- full_join(
  subgroup_comp$threshold, 
  comp_summary$threshold, 
  by = c("key", "index", "normal"))

# Finally, plot everything:
p1 <- plot_comparisons(
  filter(subgroup_comp$threshold, index == 2),
  filter(comp_summary$threshold, index == 2), 
  1, TRUE)
p2 <- plot_comparisons(
  filter(subgroup_comp$threshold, index != 2),
  filter(comp_summary$threshold, index != 2), 
  2, TRUE)

both_plts <- cowplot::plot_grid(p1, p2, ncol = 2, align="hv")
both_plts
```

## Control Data

We will now do exactly the same with the control data...

```{r comp_control, fig.height=8, echo = FALSE}

# compute probabilties
comp_summary$occ_even <- comparison_summary(subgroup_comp$occ_even, TRUE, 'rms') 


subgroup_comp$occ_even <- full_join(
  subgroup_comp$occ_even, 
  comp_summary$occ_even, 
  by = c("key", "index", "normal"))

p1 <- plot_comparisons(
  filter(subgroup_comp$occ_even, index == 2),
  filter(comp_summary$occ_even, index == 2), 
  1)
p2 <- plot_comparisons(
  filter(subgroup_comp$occ_even, index != 2),
  filter(comp_summary$occ_even, index != 2), 
  2)

both_plts <- cowplot::plot_grid(p1, p2, ncol = 2, align="hv") 
both_plts

  
# compute probabilties
comp_summary$par_odd <- comparison_summary(subgroup_comp$par_odd, TRUE, 'rms') 

subgroup_comp$par_odd <- full_join(
  subgroup_comp$par_odd, 
  comp_summary$par_odd, 
  by = c("key", "index", "normal"))

p1 <- plot_comparisons(
  filter(subgroup_comp$par_odd, index == 2),
  filter(comp_summary$par_odd, index == 2), 
  1)
p2 <- plot_comparisons(
  filter(subgroup_comp$par_odd, index != 2),
  filter(comp_summary$par_odd, index != 2), 
  2)

both_plts <- cowplot::plot_grid(p1, p2, ncol = 2, align="hv")
both_plts

```

## Summary

Some summary stats for how many subgroups show a difference. We have 64 subgroupds in total. 

```{r}

count_comparisons <- function(comparisons, p) {
  x <- sum(comparisons$prob_one_tailed >= p)
  return(x)
}

df <- tibble()

for (p in seq(0.5, 0.99, 0.01)) {

  df <- bind_rows(df, map_dbl(comp_summary,  count_comparisons, p))
}

df$p <- seq(0.5, 0.99, 0.01)

df %>% gather("measurement", "number", -p) %>%
  mutate(proportion = number/64) %>%
  ggplot(aes(x = p, y = proportion, colour = measurement)) + geom_point() + geom_path() +
  theme_minimal() + ggthemes::scale_color_ptol() +
  xlab("probability of difference given data") + ylab("proportion of subgroup comparisons")

filter(df, p == 0.95)

```

# Additional Analysis

## Index and Normality 

## Correlation Between EEG RMS and Display Duration Threshold


```{r compare_comparisons}

bind_rows(
  select(comp_summary$eeg, measurement, key, mean_value),
  select(comp_summary$threshold, measurement, key, mean_value)) %>%
  spread(measurement, mean_value) %>%
  glimpse()-> d


m <- brm(data = d, threshold ~ rms)


summary(m)

bayes_R2(m)

d %>% 
  modelr::data_grid(rms = seq(-0.2, 0.8, 0.1)) %>%
  add_fitted_draws(m, n = 100) %>%
  ggplot(aes(x = rms, y = threshold, color = index)) +
  geom_line(aes(y = .value, group = .draw), alpha = .1, colour = "thistle4") +
  geom_point(data = d) +
  theme_minimal() + 
  ggthemes::scale_colour_ptol()

```
