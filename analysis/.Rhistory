library(tidyverse)
library(brms)
library(tidybayes)
library(ggridges)
library(latex2exp)
library(see)
library(ggthemes)
library(patchwork)
library(magick)
knitr::opts_chunk$set(echo = FALSE, message=FALSE, fig.align='center')
options(knitr.table.format = "html")
# specify some colours to use in the plots
v_cols <- ggthemes::ptol_pal()(6)
# read in some helper functions that will be used later
source("scripts/helper_functions.R")
options(mc.cores = parallel::detectCores())
# Use multiple cores and set number of iterations.
options(mc.cores = parallel::detectCores())
n_iter <- 10000
# make empty lists to store things in
my_models <- list()
my_samples <- list()
comp_summary <- list()
subgroup_comp <- list()
plt <- cowplot::ggdraw() +
cowplot::draw_image("../figures/occTopo_merged.png")
print(plt)
fl <- "rms_Occ_Odd.csv"
# set column types
my_cols <- cols(
.default = col_double(),
Row = col_character()
)
#import
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
rename(wg = "Row") %>%
gather("subject", "rms", -wg) %>%
glimpse() -> d_eeg
d_eeg %>% ggplot(aes(x = rms)) +
geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
theme_lucid()
fl <- "thresholds"
my_cols_threshold <- cols(
person = col_character(),
group = col_character(),
staircase = col_double(),
threshold = col_double(),
log_threshold = col_double()
)
read_csv("../Experiment/process_results/thresholds.csv", col_types = my_cols_threshold) %>%
select(subject = "person", wg = "group", threshold) %>%
glimpse() -> d_dispthresh
rm(my_cols_threshold)
d_dispthresh %>% ggplot(aes(x = threshold)) +
geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
theme_lucid()
fl <- "rms_Occ_Even.csv"
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
rename(wg = "Row") %>%
gather("subject", "rms", -wg) -> d_eeg_occ_even
fl <- "rms_Par_Odd.csv"
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
rename(wg = "Row") %>%
gather("subject", "rms", -wg) -> d_eeg_par_odd
rm(my_cols, fl)
sym_dat <- read_csv("../subgroups/symmeries_in_group.csv") %>%
mutate(group = str_to_upper(group))
knitr::kable(sym_dat, caption = "Wallpaper group summary") %>%
kableExtra::kable_styling(full_width = F)
source("scripts/import_subgroup_comparisons.R")
opts <- options(knitr.kable.NA = "")
knitr::kable(index_table, caption = "Summary of subgroup relationships. The numbers indicate the index of the subgroup, while italics indicate normal subgroups. Relationships written in yellow text are not included in our analysis.", escape = "F") %>% kableExtra::kable_styling(full_width = F)
prior <- c(
set_prior("normal(0,2)", class = "b"),
set_prior("cauchy(0,2)", class = "sigma"))
m_prior <- brm(data = d_eeg,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior,
iter = n_iter ,
sample_prior = 'only')
prior_samples <- get_model_samples(m_prior)
# Tidy up a little
prior_predictions <- get_model_predictions(prior_samples)%>% glimpse()
# # And now plot
p1 <- plot_model_output(prior_predictions, d_eeg,
"odd-harmonic data from \noccipital electrodes", "cornflowerblue", "log(rms)")
p2 <- plot_model_output(prior_predictions, d_dispthresh,
"display duration threshold data", "cornflowerblue", "log(ms)")
# draw pot
plt <- p1 + p2
plt + plot_annotation(title = 'Prior Predictive Checks')
m_eeg <- brm(data = d_eeg,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
summary(m_eeg)
# Also fit to display duration data so I can display both models together
m_threshold <- brm(data = d_dispthresh,
threshold ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
# Extract samples from model
my_samples$eeg <- get_model_samples(m_eeg)
my_samples$threshold <- get_model_samples(m_threshold)
# Tidy up a little
my_models$eeg <- get_model_predictions(my_samples$eeg)
my_models$threshold <- get_model_predictions(my_samples$threshold)
# Plot
plt1 <- plot_model_output(
my_models$eeg, d_eeg,
"odd-harmonic data from \noccipital electrodes",
"orangered3",
"log(rms)")
plt2 <- plot_model_output(
my_models$threshold, d_dispthresh,
"Psychophysical Data",
"orangered3",
"threshold (ms)")
plt1 + plt2 + plot_annotation(title = 'Model Fits:')
summary(m_threshold)
m_eeg_par_odd <- brm(data = d_eeg_par_odd,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
my_samples$par_odd <- get_model_samples(m_eeg_par_odd)
my_models$par_odd <- get_model_predictions(my_samples$par_odd)
plt1 <- plot_model_output(my_models$par_odd, d_eeg_par_odd,
"odd-harmonic data from \nparietal electrodes", "orangered3", "threshold (ms)")
m_eeg_occ_even <- brm(data = d_eeg_occ_even,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
# Extract samples from model
my_samples$occ_even <- get_model_samples(m_eeg_occ_even)
my_models$occ_even <- get_model_predictions(my_samples$occ_even)
plt2 <- plot_model_output(my_models$occ_even, d_eeg_occ_even,
"even-harmonic data from \noccipital electrodes", "orangered3", "threshold (ms)")
plt1 + plt2 + plot_annotation(title = 'Model Fits for the ')
source("scripts/get_subgroup_comparisons.R")
subgroup_comp$eeg <- get_subgroup_comparisons2(my_samples$eeg)
subgroup_comp$threshold <- get_subgroup_comparisons2(my_samples$threshold,)
subgroup_comp$occ_even <- get_subgroup_comparisons2(my_samples$occ_even)
subgroup_comp$par_odd  <- get_subgroup_comparisons2(my_samples$par_odd)
comparison_summary <- function(subgroup_comp_dat, greater, measurement_lab) {
# compute probabilities
subgroup_comp_dat %>%
group_by(key, index, normal) %>%
summarise(
mean_value = mean(value),
prob_one_tailed = if_else(greater == TRUE, mean(value > 0), mean(value < 0)),
.groups = "drop")  %>%
mutate(
prob_one_tailed = if_else(prob_one_tailed==0, 0.01, prob_one_tailed),
measurement = measurement_lab,
index_labs = as.numeric(as.factor(index)),
lab_cols = v_cols[index_labs],
prob_cat = cut(prob_one_tailed, c(0, 0.5, 0.75, 0.9, 0.99, 1))) -> comp_summary_dat
return(comp_summary_dat)
}
# compute probabilities
comp_summary$eeg <- comparison_summary(subgroup_comp$eeg, TRUE, 'rms')
subgroup_comp$eeg <- full_join(
subgroup_comp$eeg,
comp_summary$eeg,
by = c("key", "index", "normal"))
# Finally, plot everything:
p1 <- plot_comparisons(
filter(subgroup_comp$eeg, index == 2),
filter(comp_summary$eeg, index == 2),
1)
p2 <-plot_comparisons(
filter(subgroup_comp$eeg, index != 2),
filter(comp_summary$eeg, index != 2),
2)
both_plts <- cowplot::plot_grid(p1, p2, ncol = 2, align="hv")
both_plts
ggsave("plots/subgroup_comp_eeg_rms.pdf", width = 5.5, height = 8)
source("scripts/get_subgroup_comparisons.R")
subgroup_comp$eeg <- get_subgroup_comparisons2(my_samples$eeg)
subgroup_comp$eeg <- get_subgroup_comparisons2(my_samples$eeg)
subgroup_comp$threshold <- get_subgroup_comparisons2(my_samples$threshold,)
subgroup_comp$occ_even <- get_subgroup_comparisons2(my_samples$occ_even)
comparison_summary <- function(subgroup_comp_dat, greater, measurement_lab) {
# compute probabilities
subgroup_comp_dat %>%
group_by(key, index, normal) %>%
summarise(
mean_value = mean(value),
prob_one_tailed = if_else(greater == TRUE, mean(value > 0), mean(value < 0)),
.groups = "drop")  %>%
mutate(
prob_one_tailed = if_else(prob_one_tailed==0, 0.01, prob_one_tailed),
measurement = measurement_lab,
index_labs = as.numeric(as.factor(index)),
lab_cols = v_cols[index_labs],
prob_cat = cut(prob_one_tailed, c(0, 0.5, 0.75, 0.9, 0.99, 1))) -> comp_summary_dat
return(comp_summary_dat)
}
# compute probabilities
comp_summary$eeg <- comparison_summary(subgroup_comp$eeg, TRUE, 'rms')
subgroup_comp$eeg <- full_join(
subgroup_comp$eeg,
comp_summary$eeg,
by = c("key", "index", "normal"))
# Finally, plot everything:
p1 <- plot_comparisons(
filter(subgroup_comp$eeg, index == 2),
filter(comp_summary$eeg, index == 2),
1)
p1
index_dat  <- read_csv("../subgroups/subgroup_relations.csv")
normal_dat <- read_csv("../subgroups/subgroup_normal.csv")
# sort out group names
group_names  <- str_to_upper(index_dat$group)
index_dat  <- index_dat[, -1]
normal_dat <- normal_dat[, -1]
# remove p1
group_names  <- group_names[-1]
index_dat  <- select(index_dat[-1,], -p1)
normal_dat <- select(normal_dat[-1,], -p1)
subgroups <- tibble(
group = as.character(),
subgroup = as.character(),
index = as.numeric(),
normal = as.logical())
for (ii in 1:nrow(index_dat)) {
for (jj in 1:ncol(index_dat)) {
subgroups <- add_row(subgroups,
group = group_names[jj],
subgroup = group_names[ii],
index = as.numeric(index_dat[ii,jj]),
normal = normal_dat[ii,jj] == 1)
}
}
# list of comparisons to remove
to_remove <- list(
"PM-CM", "CM-PM",
"PMM-CMM", "CMM-PMM",
"P3M1-P31M", "P31M-P3M1")
to_remove <- append(to_remove, unlist(paste(group_names, "-", group_names, sep = "")))
subgroups %>%
select(group, subgroup, index) %>%
pivot_wider(
names_from = subgroup,
values_from = index) %>%
pivot_longer(
-group,
values_to = "index",
names_to = "subgroup") %>%
left_join(subgroups) %>%
mutate(
colour_code = if_else(paste(group, subgroup, sep="-") %in% to_remove, 2, 1),
index = as.character(index),
index = if_else(is.na(index), "-", index),
index = kableExtra::cell_spec(
index,
italic = if_else(normal == TRUE, TRUE, FALSE),
color = kableExtra::spec_color(colour_code, end = 0.95, na_color = "#FFFFFF")),
) %>%
select(group, subgroup, index) %>%
pivot_wider(
names_from = group,
values_from = index) -> index_table
index_tab;e
index_table
# filter by index to remove all non-valid relations
# also remove all indentity relationships
subgroups %>% filter(
is.finite(index),
group != subgroup,
!(paste(group, subgroup, sep="-") %in% to_remove)) %>%
mutate(label = paste(subgroup, sprintf('\u2192') , group)) -> subgroups
subgroups
# filter by index to remove all non-valid relations
# also remove all indentity relationships
subgroups %>% filter(
is.finite(index),
group != subgroup,
!(paste(group, subgroup, sep="-") %in% to_remove)) %>%
mutate(label = paste(subgroup, sprintf('\u2192') , group, "(", index, ")")) -> subgroups
subgroups
# filter by index to remove all non-valid relations
# also remove all indentity relationships
subgroups %>% filter(
is.finite(index),
group != subgroup,
!(paste(group, subgroup, sep="-") %in% to_remove)) %>%
mutate(label = paste(subgroup, sprintf('\u2192') , group, "(", index, ")", sep = "")) -> subgroups
subgroups
# compute probabilities
comp_summary$eeg <- comparison_summary(subgroup_comp$eeg, TRUE, 'rms')
subgroup_comp$eeg <- full_join(
subgroup_comp$eeg,
comp_summary$eeg,
by = c("key", "index", "normal"))
# Finally, plot everything:
p1 <- plot_comparisons(
filter(subgroup_comp$eeg, index == 2),
filter(comp_summary$eeg, index == 2),
1)
p2 <-plot_comparisons(
filter(subgroup_comp$eeg, index != 2),
filter(comp_summary$eeg, index != 2),
2)
both_plts <- cowplot::plot_grid(p1, p2, ncol = 2, align="hv")
?scale_fill_grey
?patchwork::plot_layout
library(bookdown)
library(tidyverse)
library(brms)
library(tidybayes)
library(ggridges)
library(latex2exp)
library(see)
library(ggthemes)
library(patchwork)
library(magick)
knitr::opts_chunk$set(echo = FALSE, message=FALSE, fig.align='center')
options(knitr.table.format = "html")
# specify some colours to use in the plots
v_cols <- ggthemes::ptol_pal()(6)
# read in some helper functions that will be used later
source("scripts/helper_functions.R")
options(mc.cores = parallel::detectCores())
# compute probabilities
comp_summary$eeg <- comparison_summary(subgroup_comp$eeg, TRUE, 'rms')
library(bookdown)
library(tidyverse)
library(brms)
library(tidybayes)
library(ggridges)
library(latex2exp)
library(see)
library(ggthemes)
library(patchwork)
library(magick)
knitr::opts_chunk$set(echo = FALSE, message=FALSE, fig.align='center')
options(knitr.table.format = "html")
# specify some colours to use in the plots
v_cols <- ggthemes::ptol_pal()(6)
# read in some helper functions that will be used later
source("scripts/helper_functions.R")
options(mc.cores = parallel::detectCores())
# Use multiple cores and set number of iterations.
options(mc.cores = parallel::detectCores())
n_iter <- 10000
# make empty lists to store things in
my_models <- list()
my_samples <- list()
comp_summary <- list()
subgroup_comp <- list()
plt <- cowplot::ggdraw() +
cowplot::draw_image("../figures/occTopo_merged.png")
print(plt)
fl <- "rms_Occ_Odd.csv"
# set column types
my_cols <- cols(
.default = col_double(),
Row = col_character()
)
#import
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
rename(wg = "Row") %>%
gather("subject", "rms", -wg) %>%
glimpse() -> d_eeg
d_eeg %>% ggplot(aes(x = rms)) +
geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
theme_lucid()
fl <- "thresholds"
my_cols_threshold <- cols(
person = col_character(),
group = col_character(),
staircase = col_double(),
threshold = col_double(),
log_threshold = col_double()
)
read_csv("../Experiment/process_results/thresholds.csv", col_types = my_cols_threshold) %>%
select(subject = "person", wg = "group", threshold) %>%
glimpse() -> d_dispthresh
rm(my_cols_threshold)
d_dispthresh %>% ggplot(aes(x = threshold)) +
geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
theme_lucid()
fl <- "rms_Occ_Even.csv"
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
rename(wg = "Row") %>%
gather("subject", "rms", -wg) -> d_eeg_occ_even
fl <- "rms_Par_Odd.csv"
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
rename(wg = "Row") %>%
gather("subject", "rms", -wg) -> d_eeg_par_odd
rm(my_cols, fl)
sym_dat <- read_csv("../subgroups/symmeries_in_group.csv") %>%
mutate(group = str_to_upper(group))
knitr::kable(sym_dat, caption = "Wallpaper group summary") %>%
kableExtra::kable_styling(full_width = F)
source("scripts/import_subgroup_comparisons.R")
opts <- options(knitr.kable.NA = "")
knitr::kable(index_table, caption = "Summary of subgroup relationships. The numbers indicate the index of the subgroup, while italics indicate normal subgroups. Relationships written in yellow text are not included in our analysis.", escape = "F") %>% kableExtra::kable_styling(full_width = F)
prior <- c(
set_prior("normal(0,2)", class = "b"),
set_prior("cauchy(0,2)", class = "sigma"))
m_prior <- brm(data = d_eeg,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior,
iter = n_iter ,
sample_prior = 'only')
prior_samples <- get_model_samples(m_prior)
# Tidy up a little
prior_predictions <- get_model_predictions(prior_samples)%>% glimpse()
# # And now plot
p1 <- plot_model_output(prior_predictions, d_eeg,
"odd-harmonic data from \noccipital electrodes", "cornflowerblue", "log(rms)")
p2 <- plot_model_output(prior_predictions, d_dispthresh,
"display duration threshold data", "cornflowerblue", "log(ms)")
# draw pot
plt <- p1 + p2
plt + plot_annotation(title = 'Prior Predictive Checks')
m_eeg <- brm(data = d_eeg,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
summary(m_eeg)
# Also fit to display duration data so I can display both models together
m_threshold <- brm(data = d_dispthresh,
threshold ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
# Extract samples from model
my_samples$eeg <- get_model_samples(m_eeg)
my_samples$threshold <- get_model_samples(m_threshold)
# Tidy up a little
my_models$eeg <- get_model_predictions(my_samples$eeg)
my_models$threshold <- get_model_predictions(my_samples$threshold)
# Plot
plt1 <- plot_model_output(
my_models$eeg, d_eeg,
"odd-harmonic data from \noccipital electrodes",
"orangered3",
"log(rms)")
plt2 <- plot_model_output(
my_models$threshold, d_dispthresh,
"Psychophysical Data",
"orangered3",
"threshold (ms)")
plt1 + plt2 + plot_annotation(title = 'Model Fits:')
summary(m_threshold)
m_eeg_par_odd <- brm(data = d_eeg_par_odd,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
my_samples$par_odd <- get_model_samples(m_eeg_par_odd)
my_models$par_odd <- get_model_predictions(my_samples$par_odd)
plt1 <- plot_model_output(my_models$par_odd, d_eeg_par_odd,
"odd-harmonic data from \nparietal electrodes", "orangered3", "threshold (ms)")
m_eeg_occ_even <- brm(data = d_eeg_occ_even,
rms ~ wg-1 + (1|subject),
family = "lognormal",
prior = prior, iter = n_iter,
control = list(adapt_delta = 0.99))
# Extract samples from model
my_samples$occ_even <- get_model_samples(m_eeg_occ_even)
my_models$occ_even <- get_model_predictions(my_samples$occ_even)
plt2 <- plot_model_output(my_models$occ_even, d_eeg_occ_even,
"even-harmonic data from \noccipital electrodes", "orangered3", "threshold (ms)")
plt1 + plt2 + plot_annotation(title = 'Model Fits for the ')
source("scripts/get_subgroup_comparisons.R")
subgroup_comp$eeg <- get_subgroup_comparisons2(my_samples$eeg)
subgroup_comp$threshold <- get_subgroup_comparisons2(my_samples$threshold,)
subgroup_comp$occ_even <- get_subgroup_comparisons2(my_samples$occ_even)
subgroup_comp$par_odd  <- get_subgroup_comparisons2(my_samples$par_odd)
comparison_summary <- function(subgroup_comp_dat, greater, measurement_lab) {
# compute probabilities
subgroup_comp_dat %>%
group_by(key, index, normal) %>%
summarise(
mean_value = mean(value),
prob_one_tailed = if_else(greater == TRUE, mean(value > 0), mean(value < 0)),
.groups = "drop")  %>%
mutate(
prob_one_tailed = if_else(prob_one_tailed==0, 0.01, prob_one_tailed),
measurement = measurement_lab,
index_labs = as.numeric(as.factor(index)),
lab_cols = v_cols[index_labs],
prob_cat = cut(prob_one_tailed, c(0, 0.5, 0.75, 0.9, 0.99, 1))) -> comp_summary_dat
return(comp_summary_dat)
}
comp_summary$eeg <- comparison_summary(subgroup_comp$eeg, TRUE, 'rms')
subgroup_comp$eeg <- full_join(
subgroup_comp$eeg,
comp_summary$eeg,
by = c("key", "index", "normal"))
# Finally, plot everything:
p1 <- plot_comparisons(
filter(subgroup_comp$eeg, index == 2),
filter(comp_summary$eeg, index == 2),
1)
p2 <-plot_comparisons(
filter(subgroup_comp$eeg, index != 2),
filter(comp_summary$eeg, index != 2),
2)
both_plts <- p1 + p2 +  plot_layout(guides = 'collect')  & theme(legend.position = 'bottom')
both_plts
