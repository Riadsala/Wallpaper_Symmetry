---
title: "Supplementary Materials"
author: "Peter J. Kohler and Alasdair D. F. Clarke"
date:
output: bookdown::html_document2
---

This will be merged into the main file later

```{r setup, include=FALSE}
library(bookdown)
library(tidyverse)
library(brms)
library(tidybayes)
library(ggridges)
library(latex2exp)
library(see)
library(ggthemes)
library(patchwork)
library(magick)

knitr::opts_chunk$set(echo = FALSE, message=FALSE, fig.align='center')

# specify some colours to use in the plots
v_cols <- ggthemes::ptol_pal()(6)

# read in some helper functions that will be used later
source("scripts/helper_functions.R")

# options(mc.cores = parallel::detectCores())
```

# Loading packages and importing data

##  Packages

Details of packages, etc, are given below.

```{r}
sessionInfo()
```

```{r}
# Use multiple cores and set number of iterations. 
options(mc.cores = parallel::detectCores())
n_iter <- 10000

# make empty lists to store things in
my_models <- list()
my_samples <- list()
comp_summary <- list()
subgroup_comp <- list()
```

## Import Data

Here we import our data and make some summary plots.

### EEG Data

Importing the primary EEG data set. This is odd-harmonic filtered data from region-of-interest consisting of six electrodes over occipital cortex.

```{r, fig.cap = "RMS data from two of the wallpaper groups, P2 and P4M. Odd harmonics are shown in A and B, while even harmonic data are shown in C and D, and occipital and parietal regions of interest are shown in dark nad light gray, respectively. The two groups elicit very different response amplitudes for odd harmonics over occipital cortex, but for even harmonics those differences are much less pronounced."}
plt <- cowplot::ggdraw() +
  cowplot::draw_image("../figures/occTopo_merged.png")
print(plt)

```

```{r eeg_import}
fl <- "rms_Occ_Odd.csv"

# set column types
my_cols <- cols(
  .default = col_double(),
  Row = col_character()
)

#import
read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wg = "Row") %>%
  gather("subject", "rms", -wg) %>%
  glimpse() -> d_eeg 
```
 
It's clearly skewed, and negative display duration are impossible, so will fit a `glm` with `family = 'lognormal'`.

```{r cache=TRUE, fig.cap = "Data are the root-mean-squaured (rms) over the odd-harmonic filtered waveforms."}
d_eeg %>% ggplot(aes(x = rms)) + 
    geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
    theme_lucid()
```

### Threshold Data

Here we import that data and select the columns that we're interested in. Threshold gives the required display duration (in seconds) for the two stimuli to allow for accurate discrimination. 

```{r threshold_import}
fl <- "thresholds"

my_cols_threshold <- cols(
  person = col_character(),
  group = col_character(),
  staircase = col_double(),
  threshold = col_double(),
  log_threshold = col_double()
)

read_csv("../Experiment/process_results/thresholds.csv", col_types = my_cols_threshold) %>%
  select(subject = "person", wg = "group", threshold) %>%
  glimpse() -> d_dispthresh 

rm(my_cols_threshold)
```
 
As above, a summary of the data.

```{r, fig.cap="Histogram of the display duration thresholds."}
d_dispthresh %>% ggplot(aes(x = threshold)) + 
    geom_histogram(binwidth = 0.2, fill = "skyblue", colour = "black") +
    theme_lucid()
```

Again, we have a skewed distribution, so will fit with `family = 'lognormal'`.

### Control Data

In addition to the primary EEG data set, we are also importing two control data sets which are (a) even harmonic data from the same occipital electrodes, and (b) odd harmonic data from six parietal electrodes (see Figure 1.1 and the main paper).

```{r import_control}

fl <- "rms_Occ_Even.csv"

read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wg = "Row") %>%
  gather("subject", "rms", -wg) -> d_eeg_occ_even

fl <- "rms_Par_Odd.csv"

read_csv(paste("data/", fl, sep = ""), col_types = my_cols) %>%
  rename(wg = "Row") %>%
  gather("subject", "rms", -wg) -> d_eeg_par_odd

rm(my_cols, fl)
```

## Symmetry Information

### Subgroup Relationships
Import subgroup information and display a table of the relationships that we will be investigating. 

```{r}
source("scripts/import_subgroup_comparisons.R")


glimpse(subgroups)


opts <- options(knitr.kable.NA = "")

knitr::kable(index_table, caption = "subgroup index", escape = "F") %>% kableExtra::kable_styling(full_width = F)
```

### Types of Symmetry

```{r, fig.cap = "Symmetries present in each group."}
sym_dat <- read_csv("../subgroups/symmeries_in_group.csv") %>%
  mutate(group = str_to_upper(group))

sym_dat %>% pivot_longer(-group, names_to = "symmetry", values_to = "order") %>%
  ggplot(aes(x = symmetry, y = order, fill = as.factor(order))) + geom_col() + facet_wrap(~ group) +
  theme_bw() + 
  scale_y_continuous(breaks = c(2,4,6)) + 
  ggthemes::scale_fill_ptol() + 
  theme(
    panel.grid.minor=element_blank(), 
    legend.position = "none")

```

# Bayesian Analysis 

Here are the details of the Bayesian multi-level modelling. Our general approach is:

*  Use weakly-informative priors.
*  Fit a multi-level model using the lognormal distribution.
  + independent variable (wallpaper group) and one dependent variable (rms or threshold).
  + maximal random effect structure.
* Check model fit (r̂ statistics and trace plots).
* Extract mcmc samples from the posterior distributions.
* Use these samples to estimate the difference between sub- and super-groups.

## Define Priors

In this section we will specify some priors. We then then use a prior-predictive check to assess whether the prior is reasonable or not (i.e., on the same order of magnitude as our measurements).

### Fixed Effects

Our independent variable is a categorical factor with 16 levels. We will drop the intercept from our model and instead fit a coefficent for each factor level ($y \sim x - 0$). As our dependant variable will be log-transformed, we can use the priors below: 

```{r, echo = TRUE}
prior <- c(
  set_prior("normal(0,2)", class = "b"),    
  set_prior("cauchy(0,2)", class = "sigma"))
```

### Group-level Effects

We will keep the default weakly informative priors for the group-level (‘random’) effects. From the brms documentation:

> [...] restricted to be non-negative and, by default, have a half student-t prior with 3 degrees of freedom and a scale parameter that depends on the standard deviation of the response after applying the link function. Minimally, the scale parameter is 10. This prior is used (a) to be only very weakly informative in order to influence results as few as possible, while (b) providing at least some regularization to considerably improve convergence and sampling efficiency.

### Prior Predictive Check

Now we can specify our Bayesian multi-level model and priors. Note that as we are using  `sample_prior = 'only'`, the model will not learn anything from our data.  

```{r eeg_prior_pred_check, cache=TRUE, echo=TRUE}
m_prior <- brm(data = d_eeg, 
  rms ~ wg-1 + (1|subject),
  family = "lognormal", 
  prior = prior, 
  iter = n_iter ,
  sample_prior = 'only')
```

We can use this model to generate data.

```{r, fig.cap="The density plot shows the distribution of the empirical data, while the blue line shows the 66% and 95% prediction intervals.", cache=TRUE}
prior_samples <- get_model_samples(m_prior) 

# Tidy up a little
prior_predictions <- get_model_predictions(prior_samples)%>% glimpse()

# # And now plot
p1 <- plot_model_output(prior_predictions, d_eeg,
                   "odd-harmonic data from \noccipital electrodes", "cornflowerblue", "log(rms)")

p2 <- plot_model_output(prior_predictions, d_dispthresh,
                   "display duration threshold data", "cornflowerblue", "log(ms)")

# draw pot
plt <- p1 + p2
plt + plot_annotation(title = 'Prior Predictive Checks')
```

We can see that i) our priors are relatively weak as the predictions span several orders of magnitide, and ii) our empirical data falls within this range. 

## Compute Posterior 

### Fit Model to EEG Data

We will now fit the model to the data.

```{r eeg_fit_model, cache=TRUE}
m_eeg <- brm(data = d_eeg, 
             rms ~ wg-1 + (1|subject),
             family = "lognormal", 
             prior = prior, iter = n_iter,
             control = list(adapt_delta = 0.99))

summary(m_eeg)

# Also fit to display duration data so I can display both models together

m_threshold <- brm(data = d_dispthresh, 
                   threshold ~ wg-1 + (1|subject),
                   family = "lognormal", 
                   prior = prior, iter = n_iter,
                   control = list(adapt_delta = 0.99))
```

We will now look at the model's predicts for the average participant (i.e, ignoring the random intercepts). 

```{r, fig.cap ="The density plot shows the distribution of the empirical data, while the blue line shows the 66% and 95% prediction intervals."}

 # Extract samples from model
my_samples$eeg <- get_model_samples(m_eeg)
my_samples$threshold <- get_model_samples(m_threshold)
 
 # Tidy up a little
 my_models$eeg <- get_model_predictions(my_samples$eeg)
 my_models$threshold <- get_model_predictions(my_samples$threshold)
 
 # Plot
plt1 <- plot_model_output(
  my_models$eeg, d_eeg,
  "odd-harmonic data from \noccipital electrodes",
  "orangered3", 
  "log(rms)")

plt2 <- plot_model_output(
  my_models$threshold, d_dispthresh, 
  "Psychophysical Data", 
  "orangered3", 
  "threshold (ms)")

plt1 + plt2 + plot_annotation(title = 'Model Fits:')

```


## Modelling by symmetry

```{r, cache=TRUE}
d_eeg %>% rename(group = "wg") %>% left_join(sym_dat) -> dat2

m_eeg2 <- brm(data = dat2, 
             rms ~ rotation + reflection + glide + (1|subject),
             family = "lognormal", 
             prior = prior, iter = n_iter,
             control = list(adapt_delta = 0.99))

```

```{r, cache=TRUE}
d_dispthresh %>% rename(group = "wg") %>% left_join(sym_dat) -> dat3

m_disthresh2 <- brm(data = dat3, 
             threshold ~ rotation + reflection + glide + (1|subject),
             family = "lognormal", 
             prior = prior, iter = n_iter,
             control = list(adapt_delta = 0.99))

```


```{r}
summary(m_eeg2)

summary(m_disthresh2)
```

## Modelling by Subgroup

```{r}
source("scripts/get_subgroup_comparisons.R")

subgroup_comp$eeg <- get_subgroup_comparisons2(my_samples$eeg, sym_dat)

subgroup_comp$eeg

subgroup_comp$eeg %>% group_by(key) %>%
  summarise(
    d_ref = unique(d_ref),
    d_rot = unique(d_rot),
    d_gli = unique(d_gli),
    value = mean(value)
  ) -> comp_info

m <- brm(data = comp_info, value ~ d_rot + d_ref + d_gli)

```

```{r}
summary(m)

```
